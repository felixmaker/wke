/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContext {
    _unused: [u8; 0],
}
#[doc = " @typedef JSContextRef A JavaScript execution context. Holds the global object and other execution state."]
pub type JSContextRef = *const OpaqueJSContext;
pub type ULChar16 = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Config {
    _unused: [u8; 0],
}
pub type ULConfig = *mut C_Config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Renderer {
    _unused: [u8; 0],
}
pub type ULRenderer = *mut C_Renderer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Session {
    _unused: [u8; 0],
}
pub type ULSession = *mut C_Session;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_ViewConfig {
    _unused: [u8; 0],
}
pub type ULViewConfig = *mut C_ViewConfig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_View {
    _unused: [u8; 0],
}
pub type ULView = *mut C_View;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Bitmap {
    _unused: [u8; 0],
}
pub type ULBitmap = *mut C_Bitmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_String {
    _unused: [u8; 0],
}
pub type ULString = *mut C_String;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Buffer {
    _unused: [u8; 0],
}
pub type ULBuffer = *mut C_Buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_KeyEvent {
    _unused: [u8; 0],
}
pub type ULKeyEvent = *mut C_KeyEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_MouseEvent {
    _unused: [u8; 0],
}
pub type ULMouseEvent = *mut C_MouseEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_ScrollEvent {
    _unused: [u8; 0],
}
pub type ULScrollEvent = *mut C_ScrollEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadEvent {
    _unused: [u8; 0],
}
pub type ULGamepadEvent = *mut C_GamepadEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadAxisEvent {
    _unused: [u8; 0],
}
pub type ULGamepadAxisEvent = *mut C_GamepadAxisEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadButtonEvent {
    _unused: [u8; 0],
}
pub type ULGamepadButtonEvent = *mut C_GamepadButtonEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Surface {
    _unused: [u8; 0],
}
pub type ULSurface = *mut C_Surface;
pub type ULBitmapSurface = *mut C_Surface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_FontFile {
    _unused: [u8; 0],
}
pub type ULFontFile = *mut C_FontFile;
pub const kMessageSource_XML: ULMessageSource = 0;
pub const kMessageSource_JS: ULMessageSource = 1;
pub const kMessageSource_Network: ULMessageSource = 2;
pub const kMessageSource_ConsoleAPI: ULMessageSource = 3;
pub const kMessageSource_Storage: ULMessageSource = 4;
pub const kMessageSource_AppCache: ULMessageSource = 5;
pub const kMessageSource_Rendering: ULMessageSource = 6;
pub const kMessageSource_CSS: ULMessageSource = 7;
pub const kMessageSource_Security: ULMessageSource = 8;
pub const kMessageSource_ContentBlocker: ULMessageSource = 9;
pub const kMessageSource_Other: ULMessageSource = 10;
pub type ULMessageSource = ::std::os::raw::c_int;
pub const kMessageLevel_Log: ULMessageLevel = 1;
pub const kMessageLevel_Warning: ULMessageLevel = 2;
pub const kMessageLevel_Error: ULMessageLevel = 3;
pub const kMessageLevel_Debug: ULMessageLevel = 4;
pub const kMessageLevel_Info: ULMessageLevel = 5;
pub type ULMessageLevel = ::std::os::raw::c_int;
pub const kCursor_Pointer: ULCursor = 0;
pub const kCursor_Cross: ULCursor = 1;
pub const kCursor_Hand: ULCursor = 2;
pub const kCursor_IBeam: ULCursor = 3;
pub const kCursor_Wait: ULCursor = 4;
pub const kCursor_Help: ULCursor = 5;
pub const kCursor_EastResize: ULCursor = 6;
pub const kCursor_NorthResize: ULCursor = 7;
pub const kCursor_NorthEastResize: ULCursor = 8;
pub const kCursor_NorthWestResize: ULCursor = 9;
pub const kCursor_SouthResize: ULCursor = 10;
pub const kCursor_SouthEastResize: ULCursor = 11;
pub const kCursor_SouthWestResize: ULCursor = 12;
pub const kCursor_WestResize: ULCursor = 13;
pub const kCursor_NorthSouthResize: ULCursor = 14;
pub const kCursor_EastWestResize: ULCursor = 15;
pub const kCursor_NorthEastSouthWestResize: ULCursor = 16;
pub const kCursor_NorthWestSouthEastResize: ULCursor = 17;
pub const kCursor_ColumnResize: ULCursor = 18;
pub const kCursor_RowResize: ULCursor = 19;
pub const kCursor_MiddlePanning: ULCursor = 20;
pub const kCursor_EastPanning: ULCursor = 21;
pub const kCursor_NorthPanning: ULCursor = 22;
pub const kCursor_NorthEastPanning: ULCursor = 23;
pub const kCursor_NorthWestPanning: ULCursor = 24;
pub const kCursor_SouthPanning: ULCursor = 25;
pub const kCursor_SouthEastPanning: ULCursor = 26;
pub const kCursor_SouthWestPanning: ULCursor = 27;
pub const kCursor_WestPanning: ULCursor = 28;
pub const kCursor_Move: ULCursor = 29;
pub const kCursor_VerticalText: ULCursor = 30;
pub const kCursor_Cell: ULCursor = 31;
pub const kCursor_ContextMenu: ULCursor = 32;
pub const kCursor_Alias: ULCursor = 33;
pub const kCursor_Progress: ULCursor = 34;
pub const kCursor_NoDrop: ULCursor = 35;
pub const kCursor_Copy: ULCursor = 36;
pub const kCursor_None: ULCursor = 37;
pub const kCursor_NotAllowed: ULCursor = 38;
pub const kCursor_ZoomIn: ULCursor = 39;
pub const kCursor_ZoomOut: ULCursor = 40;
pub const kCursor_Grab: ULCursor = 41;
pub const kCursor_Grabbing: ULCursor = 42;
pub const kCursor_Custom: ULCursor = 43;
pub type ULCursor = ::std::os::raw::c_int;
#[doc = "\n Alpha channel only, 8-bits per pixel.\n\n Encoding: 8-bits per channel, unsigned normalized.\n\n Color-space: Linear (no gamma), alpha-coverage only.\n"]
pub const kBitmapFormat_A8_UNORM: ULBitmapFormat = 0;
#[doc = "\n Blue Green Red Alpha channels, 32-bits per pixel.\n\n Encoding: 8-bits per channel, unsigned normalized.\n\n Color-space: sRGB gamma with premultiplied linear alpha channel.\n"]
pub const kBitmapFormat_BGRA8_UNORM_SRGB: ULBitmapFormat = 1;
pub type ULBitmapFormat = ::std::os::raw::c_int;
#[doc = "\n Key-Down event type. (Does not trigger accelerator commands in WebCore)\n\n @NOTE: You should probably use RawKeyDown instead when a physical key\n        is pressed. This member is only here for historic compatibility\n        with WebCore's key event types.\n"]
pub const kKeyEventType_KeyDown: ULKeyEventType = 0;
#[doc = "\n Key-Up event type. Use this when a physical key is released.\n"]
pub const kKeyEventType_KeyUp: ULKeyEventType = 1;
#[doc = "\n Raw Key-Down type. Use this when a physical key is pressed.\n\n @NOTE: You should use RawKeyDown for physical key presses since it\n        allows WebCore to do additional command translation.\n"]
pub const kKeyEventType_RawKeyDown: ULKeyEventType = 2;
#[doc = "\n Character input event type. Use this when the OS generates text from\n a physical key being pressed (eg, WM_CHAR on Windows).\n"]
pub const kKeyEventType_Char: ULKeyEventType = 3;
pub type ULKeyEventType = ::std::os::raw::c_int;
pub const kMouseEventType_MouseMoved: ULMouseEventType = 0;
pub const kMouseEventType_MouseDown: ULMouseEventType = 1;
pub const kMouseEventType_MouseUp: ULMouseEventType = 2;
pub type ULMouseEventType = ::std::os::raw::c_int;
pub const kMouseButton_None: ULMouseButton = 0;
pub const kMouseButton_Left: ULMouseButton = 1;
pub const kMouseButton_Middle: ULMouseButton = 2;
pub const kMouseButton_Right: ULMouseButton = 3;
pub type ULMouseButton = ::std::os::raw::c_int;
pub const kScrollEventType_ScrollByPixel: ULScrollEventType = 0;
pub const kScrollEventType_ScrollByPage: ULScrollEventType = 1;
pub type ULScrollEventType = ::std::os::raw::c_int;
pub const kGamepadEventType_Connected: ULGamepadEventType = 0;
pub const kGamepadEventType_Disconnected: ULGamepadEventType = 1;
pub type ULGamepadEventType = ::std::os::raw::c_int;
pub const kFaceWinding_Clockwise: ULFaceWinding = 0;
pub const kFaceWinding_CounterClockwise: ULFaceWinding = 1;
pub type ULFaceWinding = ::std::os::raw::c_int;
#[doc = "\n Lighter hinting algorithm-- glyphs are slightly fuzzier but better\n resemble their original shape. This is achieved by snapping glyphs to the\n pixel grid only vertically which better preserves inter-glyph spacing.\n"]
pub const kFontHinting_Smooth: ULFontHinting = 0;
#[doc = "\n Default hinting algorithm-- offers a good balance between sharpness and\n shape at smaller font sizes.\n"]
pub const kFontHinting_Normal: ULFontHinting = 1;
#[doc = "\n Strongest hinting algorithm-- outputs only black/white glyphs. The result\n is usually unpleasant if the underlying TTF does not contain hints for\n this type of rendering.\n"]
pub const kFontHinting_Monochrome: ULFontHinting = 2;
pub type ULFontHinting = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULRect {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULIntRect {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULRenderTarget {
    pub is_empty: bool,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub texture_id: ::std::os::raw::c_uint,
    pub texture_width: ::std::os::raw::c_uint,
    pub texture_height: ::std::os::raw::c_uint,
    pub texture_format: ULBitmapFormat,
    pub uv_coords: ULRect,
    pub render_buffer_id: ::std::os::raw::c_uint,
}
extern "C" {
    #[doc = "\n Get the version string of the library in MAJOR.MINOR.PATCH format.\n"]
    pub fn ulVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n Get the numeric major version of the library.\n"]
    pub fn ulVersionMajor() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the numeric minor version of the library.\n"]
    pub fn ulVersionMinor() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the numeric patch version of the library.\n"]
    pub fn ulVersionPatch() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the full WebKit version string.\n"]
    pub fn ulWebKitVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n Create empty bitmap.\n"]
    pub fn ulCreateEmptyBitmap() -> ULBitmap;
}
extern "C" {
    #[doc = "\n Create bitmap with certain dimensions and pixel format.\n"]
    pub fn ulCreateBitmap(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: ULBitmapFormat,
    ) -> ULBitmap;
}
extern "C" {
    #[doc = "\n Create bitmap from existing pixel buffer. @see Bitmap for help using this function.\n"]
    pub fn ulCreateBitmapFromPixels(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: ULBitmapFormat,
        row_bytes: ::std::os::raw::c_uint,
        pixels: *const ::std::os::raw::c_void,
        size: usize,
        should_copy: bool,
    ) -> ULBitmap;
}
extern "C" {
    #[doc = "\n Create bitmap from copy.\n"]
    pub fn ulCreateBitmapFromCopy(existing_bitmap: ULBitmap) -> ULBitmap;
}
extern "C" {
    #[doc = "\n Destroy a bitmap (you should only destroy Bitmaps you have explicitly created via one of the\n creation functions above.\n"]
    pub fn ulDestroyBitmap(bitmap: ULBitmap);
}
extern "C" {
    #[doc = "\n Get the width in pixels.\n"]
    pub fn ulBitmapGetWidth(bitmap: ULBitmap) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height in pixels.\n"]
    pub fn ulBitmapGetHeight(bitmap: ULBitmap) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the pixel format.\n"]
    pub fn ulBitmapGetFormat(bitmap: ULBitmap) -> ULBitmapFormat;
}
extern "C" {
    #[doc = "\n Get the bytes per pixel.\n"]
    pub fn ulBitmapGetBpp(bitmap: ULBitmap) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the number of bytes per row.\n"]
    pub fn ulBitmapGetRowBytes(bitmap: ULBitmap) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the size in bytes of the underlying pixel buffer.\n"]
    pub fn ulBitmapGetSize(bitmap: ULBitmap) -> usize;
}
extern "C" {
    #[doc = "\n Whether or not this bitmap owns its own pixel buffer.\n"]
    pub fn ulBitmapOwnsPixels(bitmap: ULBitmap) -> bool;
}
extern "C" {
    #[doc = "\n Lock pixels for reading/writing, returns pointer to pixel buffer.\n"]
    pub fn ulBitmapLockPixels(bitmap: ULBitmap) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Unlock pixels after locking.\n"]
    pub fn ulBitmapUnlockPixels(bitmap: ULBitmap);
}
extern "C" {
    #[doc = "\n Get raw pixel buffer-- you should only call this if Bitmap is already locked.\n"]
    pub fn ulBitmapRawPixels(bitmap: ULBitmap) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Whether or not this bitmap is empty.\n"]
    pub fn ulBitmapIsEmpty(bitmap: ULBitmap) -> bool;
}
extern "C" {
    #[doc = "\n Reset bitmap pixels to 0.\n"]
    pub fn ulBitmapErase(bitmap: ULBitmap);
}
extern "C" {
    #[doc = "\n Write bitmap to a PNG on disk.\n"]
    pub fn ulBitmapWritePNG(bitmap: ULBitmap, path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = "\n This converts a BGRA bitmap to RGBA bitmap and vice-versa by swapping the red and blue channels.\n"]
    pub fn ulBitmapSwapRedBlueChannels(bitmap: ULBitmap);
}
pub type ulDestroyBufferCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = "\n Create a Buffer from existing, user-owned data without any copies. An optional, user-supplied\n callback will be called to deallocate data upon destruction.\n\n @param  data                  A pointer to the data.\n\n @param  size                  Size of the data in bytes.\n\n @param  user_data             Optional user data that will be passed to destruction_callback\n                               when the returned Buffer is destroyed.\n\n @param  destruction_callback  Optional callback that will be called upon destruction. Pass a\n                               null pointer if you don't want to be informed of destruction.\n"]
    pub fn ulCreateBuffer(
        data: *mut ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
        destruction_callback: ulDestroyBufferCallback,
    ) -> ULBuffer;
}
extern "C" {
    #[doc = "\n Create a Buffer from existing data, a deep copy of data will be made.\n"]
    pub fn ulCreateBufferFromCopy(data: *const ::std::os::raw::c_void, size: usize) -> ULBuffer;
}
extern "C" {
    #[doc = "\n Destroy buffer (you should destroy any buffers you explicitly Create).\n"]
    pub fn ulDestroyBuffer(buffer: ULBuffer);
}
extern "C" {
    #[doc = "\n Get a pointer to the raw byte data.\n"]
    pub fn ulBufferGetData(buffer: ULBuffer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Get the size in bytes.\n"]
    pub fn ulBufferGetSize(buffer: ULBuffer) -> usize;
}
extern "C" {
    #[doc = "\n Get the user data associated with this Buffer, if any.\n"]
    pub fn ulBufferGetUserData(buffer: ULBuffer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Check whether this Buffer owns its own data (Buffer was created via ulCreateBufferFromCopy).\n If this is false, Buffer will call the user-supplied destruction callback to deallocate data\n when this Buffer instance is destroyed.\n"]
    pub fn ulBufferOwnsData(buffer: ULBuffer) -> bool;
}
#[doc = "\n The callback invoked when the library wants to clear the system's clipboard.\n"]
pub type ULClipboardClearCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n The callback invoked when the library wants to read from the system's clipboard.\n\n You should store the result (if any) in 'result'.\n"]
pub type ULClipboardReadPlainTextCallback =
    ::std::option::Option<unsafe extern "C" fn(result: ULString)>;
#[doc = "\n The callback invoked when the library wants to write to the system's clipboard.\n"]
pub type ULClipboardWritePlainTextCallback =
    ::std::option::Option<unsafe extern "C" fn(text: ULString)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULClipboard {
    pub clear: ULClipboardClearCallback,
    pub read_plain_text: ULClipboardReadPlainTextCallback,
    pub write_plain_text: ULClipboardWritePlainTextCallback,
}
extern "C" {
    #[doc = "\n Create config with default values (see <Ultralight/platform/Config.h>).\n"]
    pub fn ulCreateConfig() -> ULConfig;
}
extern "C" {
    #[doc = "\n Destroy config.\n"]
    pub fn ulDestroyConfig(config: ULConfig);
}
extern "C" {
    #[doc = "\n A writable OS file path to store persistent Session data in.\n\n This data may include cookies, cached network resources, indexed DB, etc.\n\n @note Files are only written to the path when using a persistent Session.\n"]
    pub fn ulConfigSetCachePath(config: ULConfig, cache_path: ULString);
}
extern "C" {
    #[doc = "\n The relative path to the resources folder (loaded via the FileSystem API).\n\n The library loads certain resources (SSL certs, ICU data, etc.) from the FileSystem API\n during runtime (eg, `file:///resources/cacert.pem`).\n\n You can customize the relative file path to the resources folder by modifying this setting.\n\n (Default = \"resources/\")\n"]
    pub fn ulConfigSetResourcePathPrefix(config: ULConfig, resource_path_prefix: ULString);
}
extern "C" {
    #[doc = "\n The winding order for front-facing triangles.\n\n @pre Only used when GPU rendering is enabled for the View.\n\n (Default = kFaceWinding_CounterClockwise)\n"]
    pub fn ulConfigSetFaceWinding(config: ULConfig, winding: ULFaceWinding);
}
extern "C" {
    #[doc = "\n The hinting algorithm to use when rendering fonts. (Default = kFontHinting_Normal)\n\n @see ULFontHinting\n"]
    pub fn ulConfigSetFontHinting(config: ULConfig, font_hinting: ULFontHinting);
}
extern "C" {
    #[doc = "\n The gamma to use when compositing font glyphs, change this value to adjust contrast (Adobe and\n Apple prefer 1.8, others may prefer 2.2). (Default = 1.8)\n"]
    pub fn ulConfigSetFontGamma(config: ULConfig, font_gamma: f64);
}
extern "C" {
    #[doc = "\n Global user-defined CSS string (included before any CSS on the page).\n\n You can use this to override default styles for various elements on the page.\n\n @note This is an actual string of CSS, not a file path.\n"]
    pub fn ulConfigSetUserStylesheet(config: ULConfig, css_string: ULString);
}
extern "C" {
    #[doc = "\n Whether or not to continuously repaint any Views, regardless if they are dirty.\n\n This is mainly used to diagnose painting/shader issues and profile performance.\n\n (Default = False)\n"]
    pub fn ulConfigSetForceRepaint(config: ULConfig, enabled: bool);
}
extern "C" {
    #[doc = "\n The delay (in seconds) between every tick of a CSS animation.\n\n (Default = 1.0 / 60.0)\n"]
    pub fn ulConfigSetAnimationTimerDelay(config: ULConfig, delay: f64);
}
extern "C" {
    #[doc = "\n The delay (in seconds) between every tick of a smooth scroll animation.\n\n (Default = 1.0 / 60.0)\n"]
    pub fn ulConfigSetScrollTimerDelay(config: ULConfig, delay: f64);
}
extern "C" {
    #[doc = "\n The delay (in seconds) between every call to the recycler.\n\n The library attempts to reclaim excess memory during calls to the internal recycler. You can\n change how often this is run by modifying this value.\n\n (Default = 4.0)\n"]
    pub fn ulConfigSetRecycleDelay(config: ULConfig, delay: f64);
}
extern "C" {
    #[doc = "\n The size of WebCore's memory cache in bytes.\n\n @note  You should increase this if you anticipate handling pages with large resources, Safari\n        typically uses 128+ MiB for its cache.\n\n (Default = 64 * 1024 * 1024)\n"]
    pub fn ulConfigSetMemoryCacheSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The number of pages to keep in the cache. (Default: 0, none)\n\n @note\n \\parblock\n\n Safari typically caches about 5 pages and maintains an on-disk cache to support typical\n web-browsing activities.\n\n If you increase this, you should probably increase the memory cache size as well.\n\n \\endparblock\n\n (Default = 0)\n"]
    pub fn ulConfigSetPageCacheSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The system's physical RAM size in bytes.\n\n JavaScriptCore tries to detect the system's physical RAM size to set reasonable allocation\n limits. Set this to anything other than 0 to override the detected value. Size is in bytes.\n\n This can be used to force JavaScriptCore to be more conservative with its allocation strategy\n (at the cost of some performance).\n"]
    pub fn ulConfigSetOverrideRAMSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The minimum size of large VM heaps in JavaScriptCore.\n\n Set this to a lower value to make these heaps start with a smaller initial value.\n\n (Default = 32 * 1024 * 1024)\n"]
    pub fn ulConfigSetMinLargeHeapSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The minimum size of small VM heaps in JavaScriptCore.\n\n Set this to a lower value to make these heaps start with a smaller initial value.\n\n (Default = 1 * 1024 * 1024)\n"]
    pub fn ulConfigSetMinSmallHeapSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The number of threads to use in the Renderer (for parallel painting on the CPU, etc.).\n\n You can set this to a certain number to limit the number of threads to spawn.\n\n @note\n \\parblock\n\n If this value is 0, the number of threads will be determined at runtime using the following\n formula:\n\n   ```\n   max(PhysicalProcessorCount() - 1, 1)\n   ```\n\n \\endparblock\n"]
    pub fn ulConfigSetNumRendererThreads(
        config: ULConfig,
        num_renderer_threads: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n The max amount of time (in seconds) to allow repeating timers to run during each call to\n Renderer::Update.\n\n The library will attempt to throttle timers if this time budget is exceeded.\n\n (Default = 1.0 / 200.0)\n"]
    pub fn ulConfigSetMaxUpdateTime(config: ULConfig, max_update_time: f64);
}
extern "C" {
    #[doc = "\n The alignment (in bytes) of the BitmapSurface when using the CPU renderer.\n\n The underlying bitmap associated with each BitmapSurface will have row_bytes padded to reach\n this alignment.\n\n Aligning the bitmap helps improve performance when using the CPU renderer. Determining the\n proper value to use depends on the CPU architecture and max SIMD instruction set used.\n\n We generally target the 128-bit SSE2 instruction set across most PC platforms so '16' is a safe\n value to use.\n\n You can set this to '0' to perform no padding (row_bytes will always be width * 4) at a slight\n cost to performance.\n\n (Default = 16)\n"]
    pub fn ulConfigSetBitmapAlignment(config: ULConfig, bitmap_alignment: ::std::os::raw::c_uint);
}
#[doc = "\n The callback invoked when the FileSystem wants to check if a file path exists, return true if it\n exists.\n"]
pub type ULFileSystemFileExistsCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> bool>;
#[doc = "\n Get the mime-type of the file (eg \"text/html\").\n\n This is usually determined by analyzing the file extension.\n\n If a mime-type cannot be determined, you should return \"application/unknown\" for this value.\n\n The library will consume the result and call ulDestroyString() after this call returns.\n"]
pub type ULFileSystemGetFileMimeTypeCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULString>;
#[doc = "\n Get the charset / encoding of the file (eg \"utf-8\").\n\n This is only important for text-based files and is usually determined by analyzing the\n contents of the file.\n\n If a charset cannot be determined, it's usually safe to return \"utf-8\" for this value.\n\n The library will consume the result and call ulDestroyString() after this call returns.\n"]
pub type ULFileSystemGetFileCharsetCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULString>;
#[doc = "\n Open file for reading and map it to a Buffer.\n\n To minimize copies, you should map the requested file into memory and use ulCreateBuffer()\n to wrap the data pointer (unmapping should be performed in the destruction callback).\n\n If the file was unable to be opened, you should return NULL for this value.\n"]
pub type ULFileSystemOpenFileCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULBuffer>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULFileSystem {
    pub file_exists: ULFileSystemFileExistsCallback,
    pub get_file_mime_type: ULFileSystemGetFileMimeTypeCallback,
    pub get_file_charset: ULFileSystemGetFileCharsetCallback,
    pub open_file: ULFileSystemOpenFileCallback,
}
extern "C" {
    #[doc = "\n Create string from null-terminated ASCII C-string.\n"]
    pub fn ulCreateString(str_: *const ::std::os::raw::c_char) -> ULString;
}
extern "C" {
    #[doc = "\n Create string from UTF-8 buffer.\n"]
    pub fn ulCreateStringUTF8(str_: *const ::std::os::raw::c_char, len: usize) -> ULString;
}
extern "C" {
    #[doc = "\n Create string from UTF-16 buffer.\n"]
    pub fn ulCreateStringUTF16(str_: *mut ULChar16, len: usize) -> ULString;
}
extern "C" {
    #[doc = "\n Create string from copy of existing string.\n"]
    pub fn ulCreateStringFromCopy(str_: ULString) -> ULString;
}
extern "C" {
    #[doc = "\n Destroy string (you should destroy any strings you explicitly Create).\n"]
    pub fn ulDestroyString(str_: ULString);
}
extern "C" {
    #[doc = "\n Get native UTF-8 buffer data (always null-terminated).\n"]
    pub fn ulStringGetData(str_: ULString) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n Get length (in bytes) of the UTF-8 buffer data, not including null terminator.\n"]
    pub fn ulStringGetLength(str_: ULString) -> usize;
}
extern "C" {
    #[doc = "\n Whether this string is empty or not.\n"]
    pub fn ulStringIsEmpty(str_: ULString) -> bool;
}
extern "C" {
    #[doc = "\n Replaces the contents of 'str' with the contents of 'new_str'\n"]
    pub fn ulStringAssignString(str_: ULString, new_str: ULString);
}
extern "C" {
    #[doc = "\n Replaces the contents of 'str' with the contents of a C-string.\n"]
    pub fn ulStringAssignCString(str_: ULString, c_str: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\n Create a font file from an on-disk file path.\n\n @note  The file path should already exist.\n"]
    pub fn ulFontFileCreateFromFilePath(file_path: ULString) -> ULFontFile;
}
extern "C" {
    #[doc = "\n Create a font file from an in-memory buffer.\n"]
    pub fn ulFontFileCreateFromBuffer(buffer: ULBuffer) -> ULFontFile;
}
extern "C" {
    #[doc = "\n Destroy font file\n"]
    pub fn ulDestroyFontFile(font_file: ULFontFile);
}
#[doc = "\n Fallback font family name. Will be used if all other fonts fail to load.\n\n @note  This font should be guaranteed to exist (eg, ULFontLoader::load should not fail when\n        when passed this font family name).\n\n @note  The returned ULString instance will be consumed (ulDestroyString will be called on it).\n"]
pub type ULFontLoaderGetFallbackFont = ::std::option::Option<unsafe extern "C" fn() -> ULString>;
#[doc = "\n Fallback font family name that can render the specified characters. This is mainly used to\n support CJK (Chinese, Japanese, Korean) text display.\n\n @param  characters  One or more UTF-16 characters. This is almost always a single character.\n\n @param  weight      Font weight.\n\n @param  italic      Whether or not italic is requested.\n\n @return  Should return a font family name that can render the text. The returned ULString\n          instance will be consumed (ulDestroyString will be called on it).\n"]
pub type ULFontLoaderGetFallbackFontForCharacters = ::std::option::Option<
    unsafe extern "C" fn(
        characters: ULString,
        weight: ::std::os::raw::c_int,
        italic: bool,
    ) -> ULString,
>;
#[doc = "\n Get the actual font file data (TTF/OTF) for a given font description.\n\n @param  family  Font family name.\n\n @param  weight  Font weight.\n\n @param  italic  Whether or not italic is requested.\n\n @return  A font file matching the given description (either an on-disk font filepath or an\n          in-memory file buffer). You can return NULL here and the loader will fallback to\n          another font.\n"]
pub type ULFontLoaderLoad = ::std::option::Option<
    unsafe extern "C" fn(
        family: ULString,
        weight: ::std::os::raw::c_int,
        italic: bool,
    ) -> ULFontFile,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULFontLoader {
    pub get_fallback_font: ULFontLoaderGetFallbackFont,
    pub get_fallback_font_for_characters: ULFontLoaderGetFallbackFontForCharacters,
    pub load: ULFontLoaderLoad,
}
extern "C" {
    #[doc = "\n Whether or not a ULRect is empty (all members equal to 0)\n"]
    pub fn ulRectIsEmpty(rect: ULRect) -> bool;
}
extern "C" {
    #[doc = "\n Create an empty ULRect (all members equal to 0)\n"]
    pub fn ulRectMakeEmpty() -> ULRect;
}
extern "C" {
    #[doc = "\n Whether or not a ULIntRect is empty (all members equal to 0)\n"]
    pub fn ulIntRectIsEmpty(rect: ULIntRect) -> bool;
}
extern "C" {
    #[doc = "\n Create an empty ULIntRect (all members equal to 0)\n"]
    pub fn ulIntRectMakeEmpty() -> ULIntRect;
}
#[doc = "\n Render buffer description.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULRenderBuffer {
    pub texture_id: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub has_stencil_buffer: bool,
    pub has_depth_buffer: bool,
}
pub const kVertexBufferFormat_2f_4ub_2f: ULVertexBufferFormat = 0;
pub const kVertexBufferFormat_2f_4ub_2f_2f_28f: ULVertexBufferFormat = 1;
#[doc = "\n Vertex formats.\n"]
pub type ULVertexBufferFormat = ::std::os::raw::c_int;
#[doc = "\n Vertex buffer data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULVertexBuffer {
    pub format: ULVertexBufferFormat,
    pub size: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_uchar,
}
#[doc = "\n Vertex index buffer data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULIndexBuffer {
    pub size: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_uchar,
}
#[doc = "\n Raw 4x4 matrix as an array of floats\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULMatrix4x4 {
    pub data: [f32; 16usize],
}
#[doc = "\n 4-component float vector\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULvec4 {
    pub value: [f32; 4usize],
}
#[doc = "\n GPU State description.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULGPUState {
    #[doc = " Viewport width in pixels"]
    pub viewport_width: ::std::os::raw::c_uint,
    #[doc = " Viewport height in pixels"]
    pub viewport_height: ::std::os::raw::c_uint,
    #[doc = " Transform matrix-- you should multiply this with the screen-space orthographic projection\n matrix then pass to the vertex shader."]
    pub transform: ULMatrix4x4,
    #[doc = " Whether or not we should enable texturing for the current draw command."]
    pub enable_texturing: bool,
    #[doc = " Whether or not we should enable blending for the current draw command. If blending is\n disabled, any drawn pixels should overwrite existing. Mainly used so we can modify alpha\n values of the RenderBuffer during scissored clears."]
    pub enable_blend: bool,
    #[doc = " The vertex/pixel shader program pair to use for the current draw command. You should cast this\n to ShaderType to get the corresponding enum."]
    pub shader_type: ::std::os::raw::c_uchar,
    #[doc = " The render buffer to use for the current draw command."]
    pub render_buffer_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #1. (Will be 0 if none)"]
    pub texture_1_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #2. (Will be 0 if none)"]
    pub texture_2_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #3. (Will be 0 if none)"]
    pub texture_3_id: ::std::os::raw::c_uint,
    #[doc = " The following four members are passed to the pixel shader via uniforms."]
    pub uniform_scalar: [f32; 8usize],
    pub uniform_vector: [ULvec4; 8usize],
    pub clip_size: ::std::os::raw::c_uchar,
    pub clip: [ULMatrix4x4; 8usize],
    #[doc = " Whether or not scissor testing should be used for the current draw\n command."]
    pub enable_scissor: bool,
    #[doc = " The scissor rect to use for scissor testing (units in pixels)"]
    pub scissor_rect: ULIntRect,
}
#[doc = "\n Command description.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULCommand {
    pub command_type: ::std::os::raw::c_uchar,
    pub gpu_state: ULGPUState,
    #[doc = " The following members are only used with kCommandType_DrawGeometry"]
    pub geometry_id: ::std::os::raw::c_uint,
    pub indices_count: ::std::os::raw::c_uint,
    pub indices_offset: ::std::os::raw::c_uint,
}
#[doc = "\n Command list, @see ULGPUDriverUpdateCommandList"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULCommandList {
    pub size: ::std::os::raw::c_uint,
    pub commands: *mut ULCommand,
}
#[doc = "\n The callback invoked when the GPUDriver will begin dispatching commands (such as CreateTexture\n and UpdateCommandList) during the current call to ulRender().\n"]
pub type ULGPUDriverBeginSynchronizeCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n The callback invoked when the GPUDriver has finished dispatching commands during the current\n call to ulRender().\n"]
pub type ULGPUDriverEndSynchronizeCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n The callback invoked when the GPUDriver wants to get the next available texture ID.\n"]
pub type ULGPUDriverNextTextureIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n The callback invoked when the GPUDriver wants to create a texture with a\n certain ID and optional bitmap.\n\n @note: If the Bitmap is empty (ulBitmapIsEmpty), then a RTT Texture should be created\n        instead. This will be used as a backing texture for a new RenderBuffer.\n"]
pub type ULGPUDriverCreateTextureCallback = ::std::option::Option<
    unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint, bitmap: ULBitmap),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to update an existing non-RTT texture with new\n bitmap data.\n"]
pub type ULGPUDriverUpdateTextureCallback = ::std::option::Option<
    unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint, bitmap: ULBitmap),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to destroy a texture.\n"]
pub type ULGPUDriverDestroyTextureCallback =
    ::std::option::Option<unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint)>;
#[doc = "\n The callback invoked when the GPUDriver wants to generate the next available render buffer ID.\n"]
pub type ULGPUDriverNextRenderBufferIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n The callback invoked when the GPUDriver wants to create a render buffer with certain ID and\n buffer description.\n"]
pub type ULGPUDriverCreateRenderBufferCallback = ::std::option::Option<
    unsafe extern "C" fn(render_buffer_id: ::std::os::raw::c_uint, buffer: ULRenderBuffer),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to destroy a render buffer\n"]
pub type ULGPUDriverDestroyRenderBufferCallback =
    ::std::option::Option<unsafe extern "C" fn(render_buffer_id: ::std::os::raw::c_uint)>;
#[doc = "\n The callback invoked when the GPUDriver wants to generate the next available geometry ID.\n"]
pub type ULGPUDriverNextGeometryIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n The callback invoked when the GPUDriver wants to create geometry with certain ID and\n vertex/index data.\n"]
pub type ULGPUDriverCreateGeometryCallback = ::std::option::Option<
    unsafe extern "C" fn(
        geometry_id: ::std::os::raw::c_uint,
        vertices: ULVertexBuffer,
        indices: ULIndexBuffer,
    ),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to update existing geometry with new vertex/index\n data.\n"]
pub type ULGPUDriverUpdateGeometryCallback = ::std::option::Option<
    unsafe extern "C" fn(
        geometry_id: ::std::os::raw::c_uint,
        vertices: ULVertexBuffer,
        indices: ULIndexBuffer,
    ),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to destroy geometry.\n"]
pub type ULGPUDriverDestroyGeometryCallback =
    ::std::option::Option<unsafe extern "C" fn(geometry_id: ::std::os::raw::c_uint)>;
#[doc = "\n The callback invoked when the GPUDriver wants to update the command list (you should copy the\n commands to your own structure).\n"]
pub type ULGPUDriverUpdateCommandListCallback =
    ::std::option::Option<unsafe extern "C" fn(list: ULCommandList)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULGPUDriver {
    pub begin_synchronize: ULGPUDriverBeginSynchronizeCallback,
    pub end_synchronize: ULGPUDriverEndSynchronizeCallback,
    pub next_texture_id: ULGPUDriverNextTextureIdCallback,
    pub create_texture: ULGPUDriverCreateTextureCallback,
    pub update_texture: ULGPUDriverUpdateTextureCallback,
    pub destroy_texture: ULGPUDriverDestroyTextureCallback,
    pub next_render_buffer_id: ULGPUDriverNextRenderBufferIdCallback,
    pub create_render_buffer: ULGPUDriverCreateRenderBufferCallback,
    pub destroy_render_buffer: ULGPUDriverDestroyRenderBufferCallback,
    pub next_geometry_id: ULGPUDriverNextGeometryIdCallback,
    pub create_geometry: ULGPUDriverCreateGeometryCallback,
    pub update_geometry: ULGPUDriverUpdateGeometryCallback,
    pub destroy_geometry: ULGPUDriverDestroyGeometryCallback,
    pub update_command_list: ULGPUDriverUpdateCommandListCallback,
}
extern "C" {
    #[doc = "\n Sets up an orthographic projection matrix with a certain viewport width and height, multiplies\n it by 'transform', and returns the result.\n\n This should be used to calculate the model-view projection matrix for the vertex shaders using\n the current ULGPUState.\n\n The 'flip_y' can be optionally used to flip the Y coordinate-space. (Usually flip_y == true for\n OpenGL)\n"]
    pub fn ulApplyProjection(
        transform: ULMatrix4x4,
        viewport_width: f32,
        viewport_height: f32,
        flip_y: bool,
    ) -> ULMatrix4x4;
}
extern "C" {
    #[doc = "\n Create a key event, @see KeyEvent for help with the following parameters.\n"]
    pub fn ulCreateKeyEvent(
        type_: ULKeyEventType,
        modifiers: ::std::os::raw::c_uint,
        virtual_key_code: ::std::os::raw::c_int,
        native_key_code: ::std::os::raw::c_int,
        text: ULString,
        unmodified_text: ULString,
        is_keypad: bool,
        is_auto_repeat: bool,
        is_system_key: bool,
    ) -> ULKeyEvent;
}
extern "C" {
    #[doc = "\n Create a key event from native Windows event.\n"]
    pub fn ulCreateKeyEventWindows(
        type_: ULKeyEventType,
        wparam: usize,
        lparam: isize,
        is_system_key: bool,
    ) -> ULKeyEvent;
}
extern "C" {
    #[doc = "\n Destroy a key event.\n"]
    pub fn ulDestroyKeyEvent(evt: ULKeyEvent);
}
pub const kLogLevel_Error: ULLogLevel = 0;
pub const kLogLevel_Warning: ULLogLevel = 1;
pub const kLogLevel_Info: ULLogLevel = 2;
#[doc = " Logger"]
pub type ULLogLevel = ::std::os::raw::c_int;
#[doc = "\n The callback invoked when the library wants to print a message to the log.\n"]
pub type ULLoggerLogMessageCallback =
    ::std::option::Option<unsafe extern "C" fn(log_level: ULLogLevel, message: ULString)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULLogger {
    pub log_message: ULLoggerLogMessageCallback,
}
extern "C" {
    #[doc = "\n Create a mouse event, @see MouseEvent for help using this function.\n"]
    pub fn ulCreateMouseEvent(
        type_: ULMouseEventType,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        button: ULMouseButton,
    ) -> ULMouseEvent;
}
extern "C" {
    #[doc = "\n Destroy a mouse event.\n"]
    pub fn ulDestroyMouseEvent(evt: ULMouseEvent);
}
extern "C" {
    #[doc = "\n Width (in pixels).\n"]
    pub fn ulSurfaceGetWidth(surface: ULSurface) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Height (in pixels).\n"]
    pub fn ulSurfaceGetHeight(surface: ULSurface) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Number of bytes between rows (usually width * 4)\n"]
    pub fn ulSurfaceGetRowBytes(surface: ULSurface) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Size in bytes.\n"]
    pub fn ulSurfaceGetSize(surface: ULSurface) -> usize;
}
extern "C" {
    #[doc = "\n Lock the pixel buffer and get a pointer to the beginning of the data for reading/writing.\n\n Native pixel format is premultiplied BGRA 32-bit (8 bits per channel).\n"]
    pub fn ulSurfaceLockPixels(surface: ULSurface) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Unlock the pixel buffer.\n"]
    pub fn ulSurfaceUnlockPixels(surface: ULSurface);
}
extern "C" {
    #[doc = "\n Resize the pixel buffer to a certain width and height (both in pixels).\n\n This should never be called while pixels are locked.\n"]
    pub fn ulSurfaceResize(
        surface: ULSurface,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Set the dirty bounds to a certain value.\n\n This is called after the Renderer paints to an area of the pixel buffer. (The new value will be\n joined with the existing dirty_bounds())\n"]
    pub fn ulSurfaceSetDirtyBounds(surface: ULSurface, bounds: ULIntRect);
}
extern "C" {
    #[doc = "\n Get the dirty bounds.\n\n This value can be used to determine which portion of the pixel buffer has been updated since the\n last call to ulSurfaceClearDirtyBounds().\n\n The general algorithm to determine if a Surface needs display is:\n <pre>\n   if (!ulIntRectIsEmpty(ulSurfaceGetDirtyBounds(surface))) {\n       // Surface pixels are dirty and needs display.\n       // Cast Surface to native Surface and use it here (pseudo code)\n       DisplaySurface(surface);\n\n       // Once you're done, clear the dirty bounds:\n       ulSurfaceClearDirtyBounds(surface);\n  }\n  </pre>\n"]
    pub fn ulSurfaceGetDirtyBounds(surface: ULSurface) -> ULIntRect;
}
extern "C" {
    #[doc = "\n Clear the dirty bounds.\n\n You should call this after you're done displaying the Surface.\n"]
    pub fn ulSurfaceClearDirtyBounds(surface: ULSurface);
}
extern "C" {
    #[doc = "\n Get the underlying user data pointer (this is only valid if you have set a custom surface\n implementation via ulPlatformSetSurfaceDefinition).\n\n This will return nullptr if this surface is the default ULBitmapSurface.\n"]
    pub fn ulSurfaceGetUserData(surface: ULSurface) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Get the underlying Bitmap from the default Surface.\n\n @note  Do not call ulDestroyBitmap() on the returned value, it is owned by the surface.\n"]
    pub fn ulBitmapSurfaceGetBitmap(surface: ULBitmapSurface) -> ULBitmap;
}
#[doc = "\n The callback invoked when a Surface is created.\n\n @param  width  The width in pixels.\n @param  height  The height in pixels.\n\n @return  This callback should return a pointer to user-defined data for the instance. This user\n          data pointer will be passed to all other callbacks when operating on the instance.\n"]
pub type ULSurfaceDefinitionCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = "\n The callback invoked when a Surface is destroyed.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionDestroyCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = "\n The callback invoked when a Surface's width (in pixels) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetWidthCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's height (in pixels) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetHeightCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's row bytes is requested.\n\n @note  This value is also known as \"stride\". Usually width * 4.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetRowBytesCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's size (in bytes) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetSizeCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> usize>;
#[doc = "\n The callback invoked when a Surface's pixel buffer is requested to be locked for reading/writing\n (should return a pointer to locked bytes).\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionLockPixelsCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = "\n The callback invoked when a Surface's pixel buffer is requested to be unlocked after previously\n being locked.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionUnlockPixelsCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = "\n The callback invoked when a Surface is requested to be resized to a certain width/height.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n\n @param  width      Width in pixels.\n\n @param  height     Height in pixels.\n"]
pub type ULSurfaceDefinitionResizeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULSurfaceDefinition {
    pub create: ULSurfaceDefinitionCreateCallback,
    pub destroy: ULSurfaceDefinitionDestroyCallback,
    pub get_width: ULSurfaceDefinitionGetWidthCallback,
    pub get_height: ULSurfaceDefinitionGetHeightCallback,
    pub get_row_bytes: ULSurfaceDefinitionGetRowBytesCallback,
    pub get_size: ULSurfaceDefinitionGetSizeCallback,
    pub lock_pixels: ULSurfaceDefinitionLockPixelsCallback,
    pub unlock_pixels: ULSurfaceDefinitionUnlockPixelsCallback,
    pub resize: ULSurfaceDefinitionResizeCallback,
}
extern "C" {
    #[doc = "\n Set a custom Logger implementation.\n\n This is used to log debug messages to the console or to a log file.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n\n @note  ulCreateApp() will use the default logger if you never call this.\n\n @note  If you're not using ulCreateApp(), (eg, using ulCreateRenderer()) you can still use the\n        default logger by calling ulEnableDefaultLogger() (@see <AppCore/CAPI.h>)\n"]
    pub fn ulPlatformSetLogger(logger: ULLogger);
}
extern "C" {
    #[doc = "\n Set a custom FileSystem implementation.\n\n The library uses this to load all file URLs (eg, <file:///page.html>).\n\n You can provide the library with your own FileSystem implementation so that file assets are\n loaded from your own pipeline.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n\n @warning This is required to be defined before calling ulCreateRenderer()\n\n @note  ulCreateApp() will use the default platform file system if you never call this.\n\n @note  If you're not using ulCreateApp(), (eg, using ulCreateRenderer()) you can still use the\n        default platform file system by calling ulEnablePlatformFileSystem()'\n        (@see <AppCore/CAPI.h>)\n"]
    pub fn ulPlatformSetFileSystem(file_system: ULFileSystem);
}
extern "C" {
    #[doc = "\n Set a custom FontLoader implementation.\n\n The library uses this to load all system fonts.\n\n Every operating system has its own library of installed system fonts. The FontLoader interface\n is used to lookup these fonts and fetch the actual font data (raw TTF/OTF file data) for a given\n given font description.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n\n @warning This is required to be defined before calling ulCreateRenderer()\n\n @note  ulCreateApp() will use the default platform font loader if you never call this.\n\n @note  If you're not using ulCreateApp(), (eg, using ulCreateRenderer()) you can still use the\n        default platform font loader by calling ulEnablePlatformFontLoader()'\n        (@see <AppCore/CAPI.h>)\n"]
    pub fn ulPlatformSetFontLoader(font_loader: ULFontLoader);
}
extern "C" {
    #[doc = "\n Set a custom Surface implementation.\n\n This can be used to wrap a platform-specific GPU texture, Windows DIB, macOS CGImage, or any\n other pixel buffer target for display on screen.\n\n By default, the library uses a bitmap surface for all surfaces but you can override this by\n providing your own surface definition here.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n"]
    pub fn ulPlatformSetSurfaceDefinition(surface_definition: ULSurfaceDefinition);
}
extern "C" {
    #[doc = "\n Set a custom GPUDriver implementation.\n\n This should be used if you have enabled the GPU renderer in the Config and are using\n ulCreateRenderer() (which does not provide its own GPUDriver implementation).\n\n The GPUDriver interface is used by the library to dispatch GPU calls to your native GPU context\n (eg, D3D11, Metal, OpenGL, Vulkan, etc.) There are reference implementations for this interface\n in the AppCore repo.\n\n You should call this before ulCreateRenderer().\n"]
    pub fn ulPlatformSetGPUDriver(gpu_driver: ULGPUDriver);
}
extern "C" {
    #[doc = "\n Set a custom Clipboard implementation.\n\n This should be used if you are using ulCreateRenderer() (which does not provide its own\n clipboard implementation).\n\n The Clipboard interface is used by the library to make calls to the system's native clipboard\n (eg, cut, copy, paste).\n\n You should call this before ulCreateRenderer().\n"]
    pub fn ulPlatformSetClipboard(clipboard: ULClipboard);
}
extern "C" {
    #[doc = "\n Create the core renderer singleton for the library directly.\n\n Unlike ulCreateApp(), this does not use any native windows for drawing and allows you to manage\n your own runloop and painting. This method is recommended for those wishing to integrate the\n library into a game.\n\n This singleton manages the lifetime of all Views and coordinates all painting, rendering,\n network requests, and event dispatch.\n\n You should only call this once per process lifetime.\n\n You must set up your platform handlers before calling this. At a minimum, you must call\n ulPlatformSetFileSystem() and  ulPlatformSetFontLoader() before calling this.\n\n @note  You should not call this if you are using ulCreateApp(), it creates its own renderer and\n        provides default implementations for various platform handlers automatically.\n"]
    pub fn ulCreateRenderer(config: ULConfig) -> ULRenderer;
}
extern "C" {
    #[doc = "\n Destroy the renderer.\n"]
    pub fn ulDestroyRenderer(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Update timers and dispatch internal callbacks (JavaScript and network).\n"]
    pub fn ulUpdate(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Notify the renderer that a display has refreshed (you should call this after vsync).\n\n This updates animations, smooth scroll, and window.requestAnimationFrame() for all Views\n matching the display id.\n"]
    pub fn ulRefreshDisplay(renderer: ULRenderer, display_id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n Render all active Views.\n"]
    pub fn ulRender(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Attempt to release as much memory as possible. Don't call this from any callbacks or driver\n code.\n"]
    pub fn ulPurgeMemory(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Print detailed memory usage statistics to the log. (@see ulPlatformSetLogger)\n"]
    pub fn ulLogMemoryUsage(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Start the remote inspector server.\n\n While the remote inspector is active, Views that are loaded into this renderer\n will be able to be remotely inspected from another Ultralight instance either locally\n (another app on same machine) or remotely (over the network) by navigating a View to:\n\n \\code\n   inspector://<ADDRESS>:<PORT>\n \\endcode\n\n @return  Returns whether the server started successfully or not.\n"]
    pub fn ulStartRemoteInspectorServer(
        renderer: ULRenderer,
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
    ) -> bool;
}
extern "C" {
    #[doc = "\n Describe the details of a gamepad, to be used with ulFireGamepadEvent and related\n events below. This can be called multiple times with the same index if the details change.\n\n @param  renderer  The active renderer instance.\n\n @param  index   The unique index (or \"connection slot\") of the gamepad. For example,\n                 controller #1 would be \"1\", controller #2 would be \"2\" and so on.\n\n @param  id      A string ID representing the device, this will be made available\n                 in JavaScript as gamepad.id\n\n @param  axis_count  The number of axes on the device.\n\n @param  button_count  The number of buttons on the device.\n"]
    pub fn ulSetGamepadDetails(
        renderer: ULRenderer,
        index: ::std::os::raw::c_uint,
        id: ULString,
        axis_count: ::std::os::raw::c_uint,
        button_count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Fire a gamepad event (connection / disconnection).\n\n @note  The gamepad should first be described via ulSetGamepadDetails before calling this\n        function.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad>\n"]
    pub fn ulFireGamepadEvent(renderer: ULRenderer, evt: ULGamepadEvent);
}
extern "C" {
    #[doc = "\n Fire a gamepad axis event (to be called when an axis value is changed).\n\n @note  The gamepad should be connected via a previous call to ulFireGamepadEvent.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/axes>\n"]
    pub fn ulFireGamepadAxisEvent(renderer: ULRenderer, evt: ULGamepadAxisEvent);
}
extern "C" {
    #[doc = "\n Fire a gamepad button event (to be called when a button value is changed).\n\n @note  The gamepad should be connected via a previous call to ulFireGamepadEvent.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/buttons>\n"]
    pub fn ulFireGamepadButtonEvent(renderer: ULRenderer, evt: ULGamepadButtonEvent);
}
extern "C" {
    #[doc = "\n Create a scroll event, @see ScrollEvent for help using this function.\n"]
    pub fn ulCreateScrollEvent(
        type_: ULScrollEventType,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) -> ULScrollEvent;
}
extern "C" {
    #[doc = "\n Destroy a scroll event.\n"]
    pub fn ulDestroyScrollEvent(evt: ULScrollEvent);
}
extern "C" {
    #[doc = "\n Create a gamepad event, see GamepadEvent for help using this function.\n"]
    pub fn ulCreateGamepadEvent(
        index: ::std::os::raw::c_uint,
        type_: ULGamepadEventType,
    ) -> ULGamepadEvent;
}
extern "C" {
    #[doc = "\n Destroy a gamepad event.\n"]
    pub fn ulDestroyGamepadEvent(evt: ULGamepadEvent);
}
extern "C" {
    #[doc = "\n Create a gamepad axis event, see GamepadAxisEvent for help using this function.\n"]
    pub fn ulCreateGamepadAxisEvent(
        index: ::std::os::raw::c_uint,
        axis_index: ::std::os::raw::c_uint,
        value: f64,
    ) -> ULGamepadAxisEvent;
}
extern "C" {
    #[doc = "\n Destroy a gamepad axis event.\n"]
    pub fn ulDestroyGamepadAxisEvent(evt: ULGamepadAxisEvent);
}
extern "C" {
    #[doc = "\n Create a gamepad button event, see GamepadButtonEvent for help using this function.\n"]
    pub fn ulCreateGamepadButtonEvent(
        index: ::std::os::raw::c_uint,
        button_index: ::std::os::raw::c_uint,
        value: f64,
    ) -> ULGamepadButtonEvent;
}
extern "C" {
    #[doc = "\n Destroy a gamepad button event.\n"]
    pub fn ulDestroyGamepadButtonEvent(evt: ULGamepadButtonEvent);
}
extern "C" {
    #[doc = "\n Create a Session to store local data in (such as cookies, local storage, application cache,\n indexed db, etc).\n"]
    pub fn ulCreateSession(renderer: ULRenderer, is_persistent: bool, name: ULString) -> ULSession;
}
extern "C" {
    #[doc = "\n Destroy a Session.\n"]
    pub fn ulDestroySession(session: ULSession);
}
extern "C" {
    #[doc = "\n Get the default session (persistent session named \"default\").\n\n @note  This session is owned by the Renderer, you shouldn't destroy it.\n"]
    pub fn ulDefaultSession(renderer: ULRenderer) -> ULSession;
}
extern "C" {
    #[doc = "\n Whether or not is persistent (backed to disk).\n"]
    pub fn ulSessionIsPersistent(session: ULSession) -> bool;
}
extern "C" {
    #[doc = "\n Unique name identifying the session (used for unique disk path).\n"]
    pub fn ulSessionGetName(session: ULSession) -> ULString;
}
extern "C" {
    #[doc = "\n Unique numeric Id for the session.\n"]
    pub fn ulSessionGetId(session: ULSession) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = "\n The disk path to write to (used by persistent sessions only).\n"]
    pub fn ulSessionGetDiskPath(session: ULSession) -> ULString;
}
extern "C" {
    #[doc = "\n Create view configuration with default values (see <Ultralight/platform/View.h>).\n"]
    pub fn ulCreateViewConfig() -> ULViewConfig;
}
extern "C" {
    #[doc = "\n Destroy view configuration.\n"]
    pub fn ulDestroyViewConfig(config: ULViewConfig);
}
extern "C" {
    #[doc = "\n Set a user-generated id of the display (monitor, TV, or screen) that the View will be shown on.\n\n Animations are driven based on the physical refresh rate of the display. Multiple Views can\n share the same display.\n\n\n @note This is automatically managed for you when ulCreateApp() is used.\n\n @see ulRefreshDisplay()\n"]
    pub fn ulViewConfigSetDisplayId(config: ULViewConfig, display_id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n Set whether to render using the GPU renderer (accelerated) or the CPU renderer (unaccelerated).\n\n This option is only valid if you're managing the Renderer yourself (eg, you've previously\n called ulCreateRenderer() instead of ulCreateApp()).\n\n When true, the View will be rendered to an offscreen GPU texture using the GPU driver set in\n ulPlatformSetGPUDriver(). You can fetch details for the texture via ulViewGetRenderTarget().\n\n When false (the default), the View will be rendered to an offscreen pixel buffer using the\n multithreaded CPU renderer. This pixel buffer can optionally be provided by the user--\n for more info see ulViewGetSurface().\n"]
    pub fn ulViewConfigSetIsAccelerated(config: ULViewConfig, is_accelerated: bool);
}
extern "C" {
    #[doc = "\n Set whether images should be enabled (Default = True).\n"]
    pub fn ulViewConfigSetIsTransparent(config: ULViewConfig, is_transparent: bool);
}
extern "C" {
    #[doc = "\n Set the initial device scale, ie. the amount to scale page units to screen pixels. This should be\n set to the scaling factor of the device that the View is displayed on. (Default = 1.0)\n\n @note 1.0 is equal to 100% zoom (no scaling), 2.0 is equal to 200% zoom (2x scaling)\n"]
    pub fn ulViewConfigSetInitialDeviceScale(config: ULViewConfig, initial_device_scale: f64);
}
extern "C" {
    #[doc = "\n Set whether or not the View should initially have input focus. (Default = True)\n"]
    pub fn ulViewConfigSetInitialFocus(config: ULViewConfig, is_focused: bool);
}
extern "C" {
    #[doc = "\n Set whether images should be enabled (Default = True).\n"]
    pub fn ulViewConfigSetEnableImages(config: ULViewConfig, enabled: bool);
}
extern "C" {
    #[doc = "\n Set whether JavaScript should be enabled (Default = True).\n"]
    pub fn ulViewConfigSetEnableJavaScript(config: ULViewConfig, enabled: bool);
}
extern "C" {
    #[doc = "\n Set default font-family to use (Default = Times New Roman).\n"]
    pub fn ulViewConfigSetFontFamilyStandard(config: ULViewConfig, font_name: ULString);
}
extern "C" {
    #[doc = "\n Set default font-family to use for fixed fonts, eg <pre> and <code>\n (Default = Courier New).\n"]
    pub fn ulViewConfigSetFontFamilyFixed(config: ULViewConfig, font_name: ULString);
}
extern "C" {
    #[doc = "\n Set default font-family to use for serif fonts (Default = Times New Roman).\n"]
    pub fn ulViewConfigSetFontFamilySerif(config: ULViewConfig, font_name: ULString);
}
extern "C" {
    #[doc = "\n Set default font-family to use for sans-serif fonts (Default = Arial).\n"]
    pub fn ulViewConfigSetFontFamilySansSerif(config: ULViewConfig, font_name: ULString);
}
extern "C" {
    #[doc = "\n Set user agent string (See <Ultralight/platform/Config.h> for the default).\n"]
    pub fn ulViewConfigSetUserAgent(config: ULViewConfig, agent_string: ULString);
}
extern "C" {
    #[doc = "\n Create a View with certain size (in pixels).\n\n @note  You can pass null to 'session' to use the default session.\n"]
    pub fn ulCreateView(
        renderer: ULRenderer,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        view_config: ULViewConfig,
        session: ULSession,
    ) -> ULView;
}
extern "C" {
    #[doc = "\n Destroy a View.\n"]
    pub fn ulDestroyView(view: ULView);
}
extern "C" {
    #[doc = "\n Get current URL.\n\n @note Don't destroy the returned string, it is owned by the View.\n"]
    pub fn ulViewGetURL(view: ULView) -> ULString;
}
extern "C" {
    #[doc = "\n Get current title.\n\n @note Don't destroy the returned string, it is owned by the View.\n"]
    pub fn ulViewGetTitle(view: ULView) -> ULString;
}
extern "C" {
    #[doc = "\n Get the width, in pixels.\n"]
    pub fn ulViewGetWidth(view: ULView) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height, in pixels.\n"]
    pub fn ulViewGetHeight(view: ULView) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ulViewGetDisplayId(view: ULView) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Set the display id of the View.\n\n This should be called when the View is moved to another display.\n"]
    pub fn ulViewSetDisplayId(view: ULView, display_id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n Get the device scale, ie. the amount to scale page units to screen pixels.\n\n For example, a value of 1.0 is equivalent to 100% zoom. A value of 2.0 is 200% zoom.\n"]
    pub fn ulViewGetDeviceScale(view: ULView) -> f64;
}
extern "C" {
    #[doc = "\n Set the device scale.\n"]
    pub fn ulViewSetDeviceScale(view: ULView, scale: f64);
}
extern "C" {
    #[doc = "\n Whether or not the View is GPU-accelerated. If this is false, the page will be rendered\n via the CPU renderer.\n"]
    pub fn ulViewIsAccelerated(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Whether or not the View supports transparent backgrounds.\n"]
    pub fn ulViewIsTransparent(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Check if the main frame of the page is currrently loading.\n"]
    pub fn ulViewIsLoading(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Get the RenderTarget for the View.\n\n @note  Only valid if this View is GPU accelerated.\n\n        You can use this with your GPUDriver implementation to bind and display the\n        corresponding texture in your application.\n"]
    pub fn ulViewGetRenderTarget(view: ULView) -> ULRenderTarget;
}
extern "C" {
    #[doc = "\n Get the Surface for the View (native pixel buffer that the CPU renderer draws into).\n\n @note  This operation is only valid if you're managing the Renderer yourself (eg, you've\n        previously called ulCreateRenderer() instead of ulCreateApp()).\n\n        This function will return NULL if this View is GPU accelerated.\n\n        The default Surface is BitmapSurface but you can provide your own Surface implementation\n        via ulPlatformSetSurfaceDefinition.\n\n        When using the default Surface, you can retrieve the underlying bitmap by casting\n        ULSurface to ULBitmapSurface and calling ulBitmapSurfaceGetBitmap().\n"]
    pub fn ulViewGetSurface(view: ULView) -> ULSurface;
}
extern "C" {
    #[doc = "\n Load a raw string of HTML.\n"]
    pub fn ulViewLoadHTML(view: ULView, html_string: ULString);
}
extern "C" {
    #[doc = "\n Load a URL into main frame.\n"]
    pub fn ulViewLoadURL(view: ULView, url_string: ULString);
}
extern "C" {
    #[doc = "\n Resize view to a certain width and height (in pixels).\n"]
    pub fn ulViewResize(
        view: ULView,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Acquire the page's JSContext for use with JavaScriptCore API.\n\n @note  This call locks the context for the current thread. You should call\n        ulViewUnlockJSContext() after using the context so other worker threads can modify\n        JavaScript state.\n\n @note  The lock is recusive, it's okay to call this multiple times as long as you call\n        ulViewUnlockJSContext() the same number of times.\n"]
    pub fn ulViewLockJSContext(view: ULView) -> JSContextRef;
}
extern "C" {
    #[doc = "\n Unlock the page's JSContext after a previous call to ulViewLockJSContext().\n"]
    pub fn ulViewUnlockJSContext(view: ULView);
}
extern "C" {
    #[doc = "\n Evaluate a string of JavaScript and return result.\n\n @param  js_string  The string of JavaScript to evaluate.\n\n @param  exception  The address of a ULString to store a description of the last exception. Pass\n                    NULL to ignore this. Don't destroy the exception string returned, it's owned\n                    by the View.\n\n @note Don't destroy the returned string, it's owned by the View. This value is reset with every\n       call-- if you want to retain it you should copy the result to a new string via\n       ulCreateStringFromCopy().\n\n @note An example of using this API:\n       <pre>\n         ULString script = ulCreateString(\"1 + 1\");\n         ULString exception;\n         ULString result = ulViewEvaluateScript(view, script, &exception);\n         /* Use the result (\"2\") and exception description (if any) here. */\n         ulDestroyString(script);\n       </pre>\n"]
    pub fn ulViewEvaluateScript(
        view: ULView,
        js_string: ULString,
        exception: *mut ULString,
    ) -> ULString;
}
extern "C" {
    #[doc = "\n Check if can navigate backwards in history.\n"]
    pub fn ulViewCanGoBack(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Check if can navigate forwards in history.\n"]
    pub fn ulViewCanGoForward(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Navigate backwards in history.\n"]
    pub fn ulViewGoBack(view: ULView);
}
extern "C" {
    #[doc = "\n Navigate forwards in history.\n"]
    pub fn ulViewGoForward(view: ULView);
}
extern "C" {
    #[doc = "\n Navigate to arbitrary offset in history.\n"]
    pub fn ulViewGoToHistoryOffset(view: ULView, offset: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\n Reload current page.\n"]
    pub fn ulViewReload(view: ULView);
}
extern "C" {
    #[doc = "\n Stop all page loads.\n"]
    pub fn ulViewStop(view: ULView);
}
extern "C" {
    #[doc = "\n Give focus to the View.\n\n You should call this to give visual indication that the View has input focus (changes active\n text selection colors, for example).\n"]
    pub fn ulViewFocus(view: ULView);
}
extern "C" {
    #[doc = "\n Remove focus from the View and unfocus any focused input elements.\n\n You should call this to give visual indication that the View has lost input focus.\n"]
    pub fn ulViewUnfocus(view: ULView);
}
extern "C" {
    #[doc = "\n Whether or not the View has focus.\n"]
    pub fn ulViewHasFocus(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Whether or not the View has an input element with visible keyboard focus (indicated by a\n blinking caret).\n\n You can use this to decide whether or not the View should consume keyboard input events (useful\n in games with mixed UI and key handling).\n"]
    pub fn ulViewHasInputFocus(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Fire a keyboard event.\n"]
    pub fn ulViewFireKeyEvent(view: ULView, key_event: ULKeyEvent);
}
extern "C" {
    #[doc = "\n Fire a mouse event.\n"]
    pub fn ulViewFireMouseEvent(view: ULView, mouse_event: ULMouseEvent);
}
extern "C" {
    #[doc = "\n Fire a scroll event.\n"]
    pub fn ulViewFireScrollEvent(view: ULView, scroll_event: ULScrollEvent);
}
pub type ULChangeTitleCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, title: ULString),
>;
extern "C" {
    #[doc = "\n Set callback for when the page title changes.\n"]
    pub fn ulViewSetChangeTitleCallback(
        view: ULView,
        callback: ULChangeTitleCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULChangeURLCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, url: ULString),
>;
extern "C" {
    #[doc = "\n Set callback for when the page URL changes.\n"]
    pub fn ulViewSetChangeURLCallback(
        view: ULView,
        callback: ULChangeURLCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULChangeTooltipCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, tooltip: ULString),
>;
extern "C" {
    #[doc = "\n Set callback for when the tooltip changes (usually result of a mouse hover).\n"]
    pub fn ulViewSetChangeTooltipCallback(
        view: ULView,
        callback: ULChangeTooltipCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULChangeCursorCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, cursor: ULCursor),
>;
extern "C" {
    #[doc = "\n Set callback for when the mouse cursor changes.\n"]
    pub fn ulViewSetChangeCursorCallback(
        view: ULView,
        callback: ULChangeCursorCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULAddConsoleMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        source: ULMessageSource,
        level: ULMessageLevel,
        message: ULString,
        line_number: ::std::os::raw::c_uint,
        column_number: ::std::os::raw::c_uint,
        source_id: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when a message is added to the console (useful for JavaScript / network errors\n and debugging).\n"]
    pub fn ulViewSetAddConsoleMessageCallback(
        view: ULView,
        callback: ULAddConsoleMessageCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULCreateChildViewCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        opener_url: ULString,
        target_url: ULString,
        is_popup: bool,
        popup_rect: ULIntRect,
    ) -> ULView,
>;
extern "C" {
    #[doc = "\n Set callback for when the page wants to create a new View.\n\n This is usually the result of a user clicking a link with target=\"_blank\" or by JavaScript\n calling window.open(url).\n\n To allow creation of these new Views, you should create a new View in this callback, resize it\n to your container, and return it. You are responsible for displaying the returned View.\n\n You should return NULL if you want to block the action.\n"]
    pub fn ulViewSetCreateChildViewCallback(
        view: ULView,
        callback: ULCreateChildViewCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULCreateInspectorViewCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        is_local: bool,
        inspected_url: ULString,
    ) -> ULView,
>;
extern "C" {
    #[doc = "\n Set callback for when the page wants to create a new View to display the local inspector in.\n\n You should create a new View in this callback, resize it to your\n container, and return it. You are responsible for displaying the returned View.\n"]
    pub fn ulViewSetCreateInspectorViewCallback(
        view: ULView,
        callback: ULCreateInspectorViewCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULBeginLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when the page begins loading a new URL into a frame.\n"]
    pub fn ulViewSetBeginLoadingCallback(
        view: ULView,
        callback: ULBeginLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULFinishLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when the page finishes loading a URL into a frame.\n"]
    pub fn ulViewSetFinishLoadingCallback(
        view: ULView,
        callback: ULFinishLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULFailLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
        description: ULString,
        error_domain: ULString,
        error_code: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when an error occurs while loading a URL into a frame.\n"]
    pub fn ulViewSetFailLoadingCallback(
        view: ULView,
        callback: ULFailLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULWindowObjectReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when the JavaScript window object is reset for a new page load.\n\n This is called before any scripts are executed on the page and is the earliest time to setup any\n initial JavaScript state or bindings.\n\n The document is not guaranteed to be loaded/parsed at this point. If you need to make any\n JavaScript calls that are dependent on DOM elements or scripts on the page, use DOMReady\n instead.\n\n The window object is lazily initialized (this will not be called on pages with no scripts).\n"]
    pub fn ulViewSetWindowObjectReadyCallback(
        view: ULView,
        callback: ULWindowObjectReadyCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULDOMReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when all JavaScript has been parsed and the document is ready.\n\n This is the best time to make any JavaScript calls that are dependent on DOM elements or scripts\n on the page.\n"]
    pub fn ulViewSetDOMReadyCallback(
        view: ULView,
        callback: ULDOMReadyCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULUpdateHistoryCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView),
>;
extern "C" {
    #[doc = "\n Set callback for when the history (back/forward state) is modified.\n"]
    pub fn ulViewSetUpdateHistoryCallback(
        view: ULView,
        callback: ULUpdateHistoryCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Set whether or not a view should be repainted during the next call to ulRender.\n\n @note  This flag is automatically set whenever the page content changes but you can set it\n        directly in case you need to force a repaint.\n"]
    pub fn ulViewSetNeedsPaint(view: ULView, needs_paint: bool);
}
extern "C" {
    #[doc = "\n Whether or not a view should be painted during the next call to ulRender.\n"]
    pub fn ulViewGetNeedsPaint(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Create an Inspector View to inspect / debug this View locally.\n\n This will only succeed if you have the inspector assets in your filesystem-- the inspector\n will look for file:///inspector/Main.html when it first loads.\n\n You must handle ulViewSetCreateInspectorViewCallback so that the library has a View to display\n the inspector in. This function will call the callback only if an inspector view is not\n currently active.\n"]
    pub fn ulViewCreateLocalInspectorView(view: ULView);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Settings {
    _unused: [u8; 0],
}
pub type ULSettings = *mut C_Settings;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_App {
    _unused: [u8; 0],
}
pub type ULApp = *mut C_App;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Window {
    _unused: [u8; 0],
}
pub type ULWindow = *mut C_Window;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Monitor {
    _unused: [u8; 0],
}
pub type ULMonitor = *mut C_Monitor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Overlay {
    _unused: [u8; 0],
}
pub type ULOverlay = *mut C_Overlay;
extern "C" {
    #[doc = "\n Create settings with default values (see <AppCore/App.h>).\n"]
    pub fn ulCreateSettings() -> ULSettings;
}
extern "C" {
    #[doc = "\n Destroy settings.\n"]
    pub fn ulDestroySettings(settings: ULSettings);
}
extern "C" {
    #[doc = "\n Set the name of the developer of this app.\n\n This is used to generate a unique path to store local application data\n on the user's machine.\n\n Default is \"MyCompany\"\n"]
    pub fn ulSettingsSetDeveloperName(settings: ULSettings, name: ULString);
}
extern "C" {
    #[doc = "\n Set the name of this app.\n\n This is used to generate a unique path to store local application data\n on the user's machine.\n\n Default is \"MyApp\"\n"]
    pub fn ulSettingsSetAppName(settings: ULSettings, name: ULString);
}
extern "C" {
    #[doc = "\n Set the root file path for our file system, you should set this to the\n relative path where all of your app data is.\n\n This will be used to resolve all file URLs, eg file:///page.html\n\n @note  The default path is \"./assets/\"\n\n        This relative path is resolved using the following logic:\n         - Windows: relative to the executable path\n         - Linux:   relative to the executable path\n         - macOS:   relative to YourApp.app/Contents/Resources/\n"]
    pub fn ulSettingsSetFileSystemPath(settings: ULSettings, path: ULString);
}
extern "C" {
    #[doc = "\n Set whether or not we should load and compile shaders from the file system\n (eg, from the /shaders/ path, relative to file_system_path).\n\n If this is false (the default), we will instead load pre-compiled shaders\n from memory which speeds up application startup time.\n"]
    pub fn ulSettingsSetLoadShadersFromFileSystem(settings: ULSettings, enabled: bool);
}
extern "C" {
    #[doc = "\n We try to use the GPU renderer when a compatible GPU is detected.\n\n Set this to true to force the engine to always use the CPU renderer.\n"]
    pub fn ulSettingsSetForceCPURenderer(settings: ULSettings, force_cpu: bool);
}
extern "C" {
    #[doc = "\n Create the App singleton.\n\n @param  settings  Settings to customize App runtime behavior. You can pass\n                   NULL for this parameter to use default settings.\n\n @param  config  Config options for the Ultralight renderer. You can pass\n                 NULL for this parameter to use default config.\n\n @note  You should only create one of these per application lifetime.\n\n @note  Certain Config options may be overridden during App creation,\n        most commonly Config::face_winding and Config::device_scale_hint.\n"]
    pub fn ulCreateApp(settings: ULSettings, config: ULConfig) -> ULApp;
}
extern "C" {
    #[doc = "\n Destroy the App instance.\n"]
    pub fn ulDestroyApp(app: ULApp);
}
pub type ULUpdateCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = "\n Set a callback for whenever the App updates. You should update all app\n logic here.\n\n @note  This event is fired right before the run loop calls\n        Renderer::Update and Renderer::Render.\n"]
    pub fn ulAppSetUpdateCallback(
        app: ULApp,
        callback: ULUpdateCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Whether or not the App is running.\n"]
    pub fn ulAppIsRunning(app: ULApp) -> bool;
}
extern "C" {
    #[doc = "\n Get the main monitor (this is never NULL).\n\n @note  We'll add monitor enumeration later.\n"]
    pub fn ulAppGetMainMonitor(app: ULApp) -> ULMonitor;
}
extern "C" {
    #[doc = "\n Get the underlying Renderer instance.\n"]
    pub fn ulAppGetRenderer(app: ULApp) -> ULRenderer;
}
extern "C" {
    #[doc = "\n Run the main loop.\n"]
    pub fn ulAppRun(app: ULApp);
}
extern "C" {
    #[doc = "\n Quit the application.\n"]
    pub fn ulAppQuit(app: ULApp);
}
extern "C" {
    #[doc = "\n Get the monitor's DPI scale (1.0 = 100%).\n"]
    pub fn ulMonitorGetScale(monitor: ULMonitor) -> f64;
}
extern "C" {
    #[doc = "\n Get the width of the monitor (in pixels).\n"]
    pub fn ulMonitorGetWidth(monitor: ULMonitor) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height of the monitor (in pixels).\n"]
    pub fn ulMonitorGetHeight(monitor: ULMonitor) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Create a new Window.\n\n @param  monitor       The monitor to create the Window on.\n\n @param  width         The width (in screen coordinates).\n\n @param  height        The height (in screen coordinates).\n\n @param  fullscreen    Whether or not the window is fullscreen.\n\n @param  window_flags  Various window flags.\n"]
    pub fn ulCreateWindow(
        monitor: ULMonitor,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        fullscreen: bool,
        window_flags: ::std::os::raw::c_uint,
    ) -> ULWindow;
}
extern "C" {
    #[doc = "\n Destroy a Window.\n"]
    pub fn ulDestroyWindow(window: ULWindow);
}
pub type ULCloseCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, window: ULWindow),
>;
extern "C" {
    #[doc = "\n Set a callback to be notified when a window closes.\n"]
    pub fn ulWindowSetCloseCallback(
        window: ULWindow,
        callback: ULCloseCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULResizeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        window: ULWindow,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ),
>;
extern "C" {
    #[doc = "\n Set a callback to be notified when a window resizes\n (parameters are passed back in pixels).\n"]
    pub fn ulWindowSetResizeCallback(
        window: ULWindow,
        callback: ULResizeCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Get window width (in screen coordinates).\n"]
    pub fn ulWindowGetScreenWidth(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window width (in pixels).\n"]
    pub fn ulWindowGetWidth(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window height (in screen coordinates).\n"]
    pub fn ulWindowGetScreenHeight(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window height (in pixels).\n"]
    pub fn ulWindowGetHeight(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Move the window to a new position (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowMoveTo(window: ULWindow, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\n Move the window to the center of the monitor.\n"]
    pub fn ulWindowMoveToCenter(arg1: ULWindow);
}
extern "C" {
    #[doc = "\n Get the x-position of the window (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowGetPositionX(window: ULWindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the y-position of the window (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowGetPositionY(window: ULWindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get whether or not a window is fullscreen.\n"]
    pub fn ulWindowIsFullscreen(window: ULWindow) -> bool;
}
extern "C" {
    #[doc = "\n Get the DPI scale of a window.\n"]
    pub fn ulWindowGetScale(window: ULWindow) -> f64;
}
extern "C" {
    #[doc = "\n Set the window title.\n"]
    pub fn ulWindowSetTitle(window: ULWindow, title: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\n Set the cursor for a window.\n"]
    pub fn ulWindowSetCursor(window: ULWindow, cursor: ULCursor);
}
extern "C" {
    #[doc = "\n Show the window (if it was previously hidden).\n"]
    pub fn ulWindowShow(window: ULWindow);
}
extern "C" {
    #[doc = "\n Hide the window.\n"]
    pub fn ulWindowHide(window: ULWindow);
}
extern "C" {
    #[doc = "\n Whether or not the window is currently visible (not hidden).\n"]
    pub fn ulWindowIsVisible(window: ULWindow) -> bool;
}
extern "C" {
    #[doc = "\n Close a window.\n"]
    pub fn ulWindowClose(window: ULWindow);
}
extern "C" {
    #[doc = "\n Convert screen coordinates to pixels using the current DPI scale.\n"]
    pub fn ulWindowScreenToPixels(
        window: ULWindow,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Convert pixels to screen coordinates using the current DPI scale.\n"]
    pub fn ulWindowPixelsToScreen(
        window: ULWindow,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the underlying native window handle.\n\n @note This is:  - HWND on Windows\n                 - NSWindow* on macOS\n                 - GLFWwindow* on Linux\n"]
    pub fn ulWindowGetNativeHandle(window: ULWindow) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Create a new Overlay.\n\n @param  window  The window to create the Overlay in.\n\n @param  width   The width in pixels.\n\n @param  height  The height in pixels.\n\n @param  x       The x-position (offset from the left of the Window), in\n                 pixels.\n\n @param  y       The y-position (offset from the top of the Window), in\n                 pixels.\n\n @note  Each Overlay is essentially a View and an on-screen quad. You should\n        create the Overlay then load content into the underlying View.\n"]
    pub fn ulCreateOverlay(
        window: ULWindow,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ULOverlay;
}
extern "C" {
    #[doc = "\n Create a new Overlay, wrapping an existing View.\n\n @param  window  The window to create the Overlay in. (we currently only\n                 support one window per application)\n\n @param  view    The View to wrap (will use its width and height).\n\n @param  x       The x-position (offset from the left of the Window), in\n                 pixels.\n\n @param  y       The y-position (offset from the top of the Window), in\n                 pixels.\n\n @note  Each Overlay is essentially a View and an on-screen quad. You should\n        create the Overlay then load content into the underlying View.\n"]
    pub fn ulCreateOverlayWithView(
        window: ULWindow,
        view: ULView,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ULOverlay;
}
extern "C" {
    #[doc = "\n Destroy an overlay.\n"]
    pub fn ulDestroyOverlay(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Get the underlying View.\n"]
    pub fn ulOverlayGetView(overlay: ULOverlay) -> ULView;
}
extern "C" {
    #[doc = "\n Get the width (in pixels).\n"]
    pub fn ulOverlayGetWidth(overlay: ULOverlay) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height (in pixels).\n"]
    pub fn ulOverlayGetHeight(overlay: ULOverlay) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the x-position (offset from the left of the Window), in pixels.\n"]
    pub fn ulOverlayGetX(overlay: ULOverlay) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the y-position (offset from the top of the Window), in pixels.\n"]
    pub fn ulOverlayGetY(overlay: ULOverlay) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Move the overlay to a new position (in pixels).\n"]
    pub fn ulOverlayMoveTo(overlay: ULOverlay, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\n Resize the overlay (and underlying View), dimensions should be\n specified in pixels.\n"]
    pub fn ulOverlayResize(
        overlay: ULOverlay,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Whether or not the overlay is hidden (not drawn).\n"]
    pub fn ulOverlayIsHidden(overlay: ULOverlay) -> bool;
}
extern "C" {
    #[doc = "\n Hide the overlay (will no longer be drawn).\n"]
    pub fn ulOverlayHide(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Show the overlay.\n"]
    pub fn ulOverlayShow(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Whether or not an overlay has keyboard focus.\n"]
    pub fn ulOverlayHasFocus(overlay: ULOverlay) -> bool;
}
extern "C" {
    #[doc = "\n Grant this overlay exclusive keyboard focus.\n"]
    pub fn ulOverlayFocus(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Remove keyboard focus.\n"]
    pub fn ulOverlayUnfocus(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the platform font loader and sets it as the current FontLoader.\n"]
    pub fn ulEnablePlatformFontLoader();
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the platform file system (needed for loading file:/// URLs) and\n sets it as the current FileSystem.\n\n You can specify a base directory path to resolve relative paths against.\n"]
    pub fn ulEnablePlatformFileSystem(base_dir: ULString);
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the default logger (writes the log to a file).\n\n You should specify a writable log path to write the log to\n for example \"./ultralight.log\".\n"]
    pub fn ulEnableDefaultLogger(log_path: ULString);
}
